---
interface Props {
  models: string[];
}

const { models } = Astro.props;
---

<div class="model-filter">
  <span class="filter-label">Filter by Model:</span>
  <div class="filter-buttons">
    <button class="filter-btn active" data-model="all">All</button>
    {models.map((model) => (
      <button class="filter-btn" data-model={model}>{model}</button>
    ))}
  </div>
</div>

<style>
  .model-filter {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1.25rem;
    background: rgba(var(--accent-dark), 0.5);
    border-radius: 12px;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
  }

  .filter-label {
    font-size: 0.9rem;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.7);
    white-space: nowrap;
  }

  .filter-buttons {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .filter-btn {
    padding: 0.5rem 1rem;
    font-size: 0.85rem;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(var(--accent-light), 0.2);
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .filter-btn:hover {
    background: rgba(var(--accent), 0.3);
    border-color: rgba(var(--accent-light), 0.4);
  }

  .filter-btn.active {
    background: rgba(var(--accent), 0.5);
    border-color: rgb(var(--accent-light));
    color: white;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const filterButtons = document.querySelectorAll('.filter-btn') as NodeListOf<HTMLButtonElement>;
    const grid = document.querySelector('.logos-grid') as HTMLElement;
    const cards = Array.from(grid?.querySelectorAll('.logo-card') || []) as HTMLElement[];
    const loadingIndicator = document.querySelector('.loading-indicator') as HTMLElement;
    const scrollSentinel = document.querySelector('.scroll-sentinel') as HTMLElement;

    const itemsPerBatch = 12;
    let currentModel = 'all';
    let visibleCount = 0;
    let isLoading = false;
    let hasMore = true;

    // Get ad banner template with real ad
    function createAdBanner(slotNumber: number): HTMLElement {
      const adBanner = document.createElement('div');
      adBanner.className = 'ad-banner';
      adBanner.dataset.adSlot = slotNumber.toString();

      const adContent = document.createElement('div');
      adContent.className = 'ad-content';

      const adLabel = document.createElement('div');
      adLabel.className = 'ad-label';
      adLabel.textContent = 'Advertisement';

      const adContainer = document.createElement('div');
      adContainer.className = 'ad-container';
      adContainer.id = `ad-container-${slotNumber}`;

      adContent.appendChild(adLabel);
      adContent.appendChild(adContainer);
      adBanner.appendChild(adContent);

      // Load ad script after element is added to DOM
      setTimeout(() => {
        // Set ad options
        (window as any).atOptions = {
          'key': '882d73406cd815f47161aad7e2526995',
          'format': 'iframe',
          'height': 90,
          'width': 728,
          'params': {}
        };

        // Create and inject the ad script
        const script = document.createElement('script');
        script.src = 'https://www.highperformanceformat.com/882d73406cd815f47161aad7e2526995/invoke.js';
        script.async = true;
        adContainer.appendChild(script);
      }, 100);

      return adBanner;
    }

    function getFilteredCards(): HTMLElement[] {
      if (currentModel === 'all') {
        return cards;
      }
      return cards.filter(card => {
        const modelBadge = card.querySelector('.model-badge');
        return modelBadge?.textContent === currentModel;
      });
    }

    function resetDisplay() {
      // Hide all cards
      cards.forEach(card => {
        card.style.display = 'none';
        card.classList.remove('fade-in');
      });

      // Remove all dynamically inserted ad banners
      const adBanners = grid.querySelectorAll('.ad-banner');
      adBanners.forEach(ad => ad.remove());

      // Reset state
      visibleCount = 0;
      hasMore = true;

      // Load initial batch
      loadMoreItems();
    }

    function loadMoreItems() {
      if (isLoading || !hasMore) return;

      isLoading = true;
      if (loadingIndicator) {
        loadingIndicator.style.display = 'flex';
      }

      // Simulate a slight delay for smoother UX
      setTimeout(() => {
        const filteredCards = getFilteredCards();
        const start = visibleCount;
        const end = Math.min(start + itemsPerBatch, filteredCards.length);

        // If this is not the first batch, insert an ad banner before loading more
        if (start > 0 && start < filteredCards.length) {
          const adSlot = Math.floor(start / itemsPerBatch);
          const adBanner = createAdBanner(adSlot);

          // Find the last visible card and insert ad after it
          const lastVisibleCard = filteredCards[start - 1];
          if (lastVisibleCard && lastVisibleCard.parentNode) {
            lastVisibleCard.parentNode.insertBefore(adBanner, lastVisibleCard.nextSibling);
          }
        }

        // Show the next batch of cards with fade-in animation
        for (let i = start; i < end; i++) {
          const card = filteredCards[i];
          card.style.display = '';
          // Stagger the fade-in animation
          setTimeout(() => {
            card.classList.add('fade-in');
          }, (i - start) * 50);
        }

        visibleCount = end;
        hasMore = visibleCount < filteredCards.length;

        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }

        isLoading = false;

        // Update URL
        updateURL();
      }, 200);
    }

    function updateURL() {
      const url = new URL(window.location.href);

      if (currentModel === 'all') {
        url.searchParams.delete('model');
      } else {
        url.searchParams.set('model', currentModel);
      }

      // Remove page param as we're using infinite scroll now
      url.searchParams.delete('page');

      window.history.replaceState({ model: currentModel }, '', url.toString());
    }

    function getModelFromURL(): string {
      const params = new URLSearchParams(window.location.search);
      return params.get('model') || 'all';
    }

    // Initialize Intersection Observer for infinite scroll
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !isLoading && hasMore) {
          loadMoreItems();
        }
      });
    }, {
      root: null,
      rootMargin: '200px',
      threshold: 0
    });

    if (scrollSentinel) {
      observer.observe(scrollSentinel);
    }

    // Filter button click handlers
    filterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const model = btn.dataset.model || 'all';
        if (model !== currentModel) {
          currentModel = model;

          // Update button states
          filterButtons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          // Reset and reload with new filter
          resetDisplay();

          // Scroll to grid
          if (grid) {
            grid.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }
      });
    });

    // Handle browser back/forward
    window.addEventListener('popstate', () => {
      const model = getModelFromURL();
      if (model !== currentModel) {
        currentModel = model;

        // Update button states
        filterButtons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.model === currentModel);
        });

        resetDisplay();
      }
    });

    // Initialize from URL
    currentModel = getModelFromURL();
    filterButtons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.model === currentModel);
    });

    // Initial load
    resetDisplay();
  });
</script>
